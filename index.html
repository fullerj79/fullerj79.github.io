<head>
  <link rel="stylesheet" href="assets/site.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>

<div class="wrap">

  <div class="hero">
    <img class="headshot" src="assets/headshot.jpg" alt="Professional headshot of Jason Fuller">

    <div style="flex:1;">
      <div class="hero-top">
        <div>
          <h1>Jason Fuller</h1>
          <p class="subtitle">Computer Science · Southern New Hampshire University (SNHU)</p>
        </div>

        <div class="socials">
          <a class="icon-btn" href="mailto:jasonfuller1979@gmail.com" aria-label="Email Jason" title="Email">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M4 6h16v12H4z" fill="none" stroke="currentColor" stroke-width="2"></path>
              <path d="M4 7l8 6 8-6" fill="none" stroke="currentColor" stroke-width="2"></path>
            </svg>
          </a>
          <a class="icon-btn" href="https://www.linkedin.com/in/jason-fuller-2569347" target="_blank" rel="noopener" aria-label="Jason on LinkedIn" title="LinkedIn">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M4 4h4v16H4zM6 3.5a2 2 0 110 4 2 2 0 010-4zM10 9h4v2c.6-1.2 2.2-2.2 4.2-2.2C21 8.8 22 10.6 22 13v7h-4v-6.2c0-1.5-.5-2.5-1.8-2.5-1 0-1.6.7-1.9 1.3-.1.2-.1.6-.1.9V20h-4z" fill="currentColor"></path>
            </svg>
          </a>

          <a class="icon-btn" href="https://github.com/fullerj79" target="_blank" rel="noopener" aria-label="Jason on GitHub" title="GitHub">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path fill="currentColor" d="M12 2a10 10 0 00-3.2 19.5c.5.1.7-.2.7-.5v-1.8c-2.9.6-3.5-1.4-3.5-1.4-.5-1.2-1.1-1.5-1.1-1.5-.9-.6.1-.6.1-.6 1 .1 1.6 1 1.6 1 .9 1.6 2.4 1.1 3 .9.1-.7.4-1.1.7-1.4-2.3-.3-4.7-1.1-4.7-5a3.9 3.9 0 011-2.7 3.6 3.6 0 01.1-2.7s.9-.3 2.8 1a9.7 9.7 0 015.2 0c1.9-1.3 2.8-1 2.8-1a3.6 3.6 0 01.1 2.7 3.9 3.9 0 011 2.7c0 3.9-2.4 4.7-4.7 5 .4.3.8 1 .8 2.1v3.1c0 .3.2.6.7.5A10 10 0 0012 2z"></path>
            </svg>
          </a>

          <a class="icon-btn" href="https://meritpages.com/JasonFuller" target="_blank" rel="noopener" aria-label="Merits &amp; Honors" title="Merits &amp; Honors">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2l2.5 6 6.5.5-5 4.2 1.6 6.3-5.6-3.4-5.6 3.4 1.6-6.3-5-4.2L9.5 8z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"></path>
            </svg>
          </a>
        </div>
      </div>

      <div class="pill-row">
        <span class="pill"><strong>A.S.:</strong> Computer Science (’25) GPA: 4.0/4.0</span>
        <span class="pill"><strong>B.S.:</strong> Computer Science (’26)</span>
        <i><span class="pill"><strong>MBA:</strong> Business Administration (’27)</span></i>
      </div>

      <div class="honors">
        <strong>Honor Societies:</strong>

        <a class="honor-badge nsls" href="https://www.nsls.org/" target="_blank" rel="noopener" aria-label="NSLS" title="NSLS">
          <img src="assets/NSLS-Logo.png" alt="NSLS logo">
        </a>

        <a class="honor-badge asl" href="https://www.alsiglam.org/" target="_blank" rel="noopener" aria-label="Alpha Sigma Lambda" title="Alpha Sigma Lambda">
          <img src="assets/alsiglam-logo.jpg" alt="Alpha Sigma Lambda logo">
          <span class="honor-text">ΑΣΛ</span>
        </a>
      </div>
    </div>
  </div>

  <div class="nav-wrap">
    <div class="nav-bar">
      <span class="jump-label">Jump To:</span>

      <div class="nav-links" aria-label="Jump to page sections">
        <div class="nav-item">
          <a href="#about-me">About Me</a>
          <span class="nav-sep">|</span>
          <a href="#capstone">Capstone Overview</a>
          <span class="nav-sep">|</span>
          <a href="#enhancements">Capstone Enhancements</a>
          <span class="nav-sep">|</span>
          <a href="#contact">Contact</a>
        </div>
      </div>

    </div>
  </div>

  <div class="section" id="about-me">
    <h2><span class="bar"></span>Professional Self-Assessment</h2>

    <h3>Executive Perspective</h3>

    <p>
      I am an infrastructure and platform engineering leader with more than two decades of experience delivering resilient, enterprise-scale systems for broadcast, media, and streaming environments. I returned to complete a Computer Science degree to formalize and modernize the foundation beneath that experience, strengthen my software engineering depth, and ensure my leadership remains aligned with the direction the industry is moving.
    </p>

    <p>
      My career began in May 2000 as a help desk contractor at The Walt Disney Company. In December 2001, I was hired as a full-time employee and moved into scripting and automation work long before DevOps had a name. From there, each transition followed a consistent pattern: stabilize what is fragile, modernize what is aging, and build what the business will need next.
    </p>

    <p>
      Over time, I have led teams across media storage, compute and storage platforms, CI/CD and state management, embedded engineering, automation and self-service platforms, hybrid cloud enablement, and resilience engineering. I currently operate at the executive level, accountable for platform reliability, modernization strategy, operational readiness, and technical risk reduction in high-visibility environments.
    </p>

    <h3>Why I Returned to Computer Science</h3>

    <p>
      In 2023, after moving my twins into their college dorms, I made the deliberate decision to return to higher education. It was both personal and professional. I wanted to finish what I had started decades earlier, lead by example for my family, and ensure that my leadership remains grounded in modern computer science principles rather than legacy habits.
    </p>

    <p>
      While my career provided deep experiential learning, the program strengthened areas that matter in today’s software-driven world: algorithmic reasoning, modern language fluency, structured software engineering, database design beyond traditional relational models, and formal security thinking. It sharpened how I evaluate systems, not just how I operate them.
    </p>

    <h3>Growth Areas Strengthened Through the Program</h3>

    <p>
      The following competencies reflect how the Computer Science program refined and modernized my technical foundation. While my leadership experience spans decades, this academic journey sharpened precision, reinforced engineering discipline, and strengthened the formal computer science principles that now underpin both my executive decision making and my technical credibility.
    </p>

    <button class="toggle-btn"
            onclick="toggleContent('growth-content', this, 'View Detailed Competency Breakdown', 'Hide Detailed Competency Breakdown')"
            aria-expanded="false"
            aria-controls="growth-content">
      View Detailed Competency Breakdown
    </button>

    <div id="growth-content" class="collapsible">

      <h4>Collaboration and Organizational Alignment</h4>
      <p>
        Throughout my career I have led cross-functional engineering teams, but the Computer Science program strengthened how I structure collaboration at the design level. Coursework in software development lifecycle, object-oriented analysis, and structured design reinforced the value of business requirements documents, solution design documentation, separation of concerns, and user-centric thinking. Applying formal methodologies such as Scrum and iterative design clarified how architectural decisions either enable or constrain collaboration. The program helped me sharpen how I define boundaries, document intent, and create systems that multiple engineers can extend safely and predictably.
      </p>

      <h4>Stakeholder Communication</h4>
      <p>
        As an executive leader, I regularly communicate infrastructure strategy to senior leadership. The program refined how I articulate technical tradeoffs in a disciplined and technically grounded way. Writing structured design narratives, documenting pseudocode, and presenting architectural diagrams strengthened my ability to explain not only what a system does, but why certain approaches were selected over alternatives. This reinforced my ability to translate between engineering detail and business impact without oversimplifying either.
      </p>

      <h4>Data Structures and Algorithmic Thinking</h4>
      <p>
        Experience develops instinct, but formal study sharpens precision. The program deepened my understanding of algorithmic efficiency, graph modeling, state management, and complexity analysis. Rather than relying solely on pattern recognition built over years of operational work, I strengthened my ability to evaluate correctness, performance tradeoffs, and scalability from first principles. This has influenced how I approach capacity planning, dependency analysis, and failure domain reduction in enterprise systems.
      </p>

      <h4>Software Engineering and Database Design</h4>
      <p>
        Modern infrastructure is increasingly software-defined, and the program reinforced disciplined engineering practices that align directly with that reality. Coursework emphasized modular architecture, layered design, controlled state transitions, testing discipline, and clear responsibility boundaries. Expanding beyond traditional relational databases into document-oriented modeling broadened how I think about persistence, indexing strategies, and workload-aligned schema design. This strengthened my ability to evaluate when flexibility, normalization, or performance should drive design decisions.
      </p>

      <h4>Security as a Design Responsibility</h4>
      <p>
        Security has always been part of my operational accountability, but the program formalized a more structured adversarial mindset. Coursework in secure coding and system design reinforced least-privilege access, input validation, encryption in transit, and deliberate trust boundary definition. It sharpened how I identify potential attack surfaces early in the design phase rather than addressing vulnerabilities reactively. This perspective aligns directly with my executive responsibility for platform governance, audit readiness, and operational resilience.
      </p>

    </div>


    <h3>How This Portfolio Demonstrates Technical Leadership</h3>
    <p>
      This ePortfolio reflects a deliberate progression rather than a collection of disconnected projects. A foundational artifact was intentionally selected and enhanced across software engineering design, algorithmic rigor, and database integration to demonstrate breadth and depth within a unified system.
    </p>

    <p>
      Each enhancement category builds on the previous one. Architectural structure establishes clarity and maintainability. Algorithmic refinement strengthens correctness and measurable reasoning. Database integration introduces persistence, scalability, and production awareness. Together, these layers reflect how real systems evolve over time through disciplined iteration rather than isolated feature development.
    </p>
    
    <p>
      The portfolio is designed to show more than functional code. It demonstrates structured problem solving, evaluation of tradeoffs, modern deployment practices, and embedded security considerations. It reflects how I approach technology as both an engineer and an executive: grounded in computer science principles, aligned to business outcomes, and intentional about long-term sustainability.
    </p>

    <p>
      The sections that follow introduce the capstone context, the original artifact, and the enhancement strategy in greater detail, illustrating how these components work together to represent a cohesive and production-minded solution.
    </p>

  </div>

  <div class="section" id="capstone">
    <h2><span class="bar"></span>Capstone Overview</h2>

    <!-- Clickable Logo Banner -->
    <div style="text-align:center; margin-bottom:1.25rem;">
      <a href="https://relicrush.onrender.com" target="_blank" rel="noopener">
        <div style="
          width:100%;
          max-width:920px;
          height:260px;
          margin:0 auto;
          overflow:hidden;
          border-radius:18px;
          box-shadow:0 18px 40px rgba(0,0,0,.18);
          cursor:pointer;">
          <img 
            src="enhanced_artifacts/assets/logo_rectangle.png" 
            alt="RelicRush Application Banner"
            style="width:100%; height:100%; object-fit:cover; object-position:center; display:block;">
        </div>
      </a>

      <div style="margin-top:.65rem; font-size:.85rem; color:var(--muted); letter-spacing:.02em;">
        RelicRush | Enhanced CS 499 Capstone Artifact<br/>
        Deployed on Render with MongoDB Atlas
      </div>
    </div>


    <h3>Purpose of the Capstone</h3>

    <p>
      The objective of CS 499 is not simply to build software. It is to demonstrate the ability to evaluate an existing artifact, apply computer science principles deliberately, and evolve that artifact in ways that reflect professional engineering standards. The capstone requires structured enhancement across three domains: software engineering and design, algorithms and data structures, and databases.
    </p>

    <p>
      Rather than selecting unrelated projects, I intentionally chose a single foundational artifact and enhanced it across all three categories. This approach allowed me to demonstrate architectural progression, algorithmic rigor, and persistent data modeling within one cohesive system.
    </p>


    <h3>Original Artifact</h3>

    <p>
      The starting point was a Python-based console adventure game originally developed in IT-140: Introduction to Scripting. The original version was a single-file program using dictionaries and control flow to manage room navigation and item collection. It achieved its academic goal, but architecturally it was tightly coupled, state was ephemeral, and there was no persistence, authentication, or deployment model.
    </p>

    <!-- ORIGINAL LABEL -->
    <div style="text-align:center; font-size:.85rem; font-weight:600; letter-spacing:.05em; margin-top:2rem; color:var(--muted); text-transform:uppercase;">
      Original Console Interface
    </div>

    <!-- ORIGINAL CONSOLE IMAGES SIDE BY SIDE -->
    <div style="display:flex; justify-content:center; gap:2rem; flex-wrap:wrap; margin:1.5rem auto 1rem auto; max-width:1100px;">

      <a href="assets/original_start.jpg" target="_blank" rel="noopener" style="width:48%;">
        <img 
          src="assets/original_start.jpg"
          alt="Original Console Instructions"
          style="width:100%; height:auto; border-radius:16px; box-shadow:0 18px 40px rgba(0,0,0,.18);">
      </a>

      <a href="assets/original_win.jpg" target="_blank" rel="noopener" style="width:48%;">
        <img 
          src="assets/original_win.jpg"
          alt="Original Console Win Screen"
          style="width:100%; height:auto; border-radius:16px; box-shadow:0 18px 40px rgba(0,0,0,.18);">
      </a>

    </div>

    <div style="text-align:center; font-size:.85rem; color:var(--muted); margin-bottom:1.75rem;">
      Console-based CLI demonstrating instructional flow and successful completion state.
    </div>

    <!-- ORIGINAL BUTTONS -->
    <div class="callout" style="margin-bottom:2rem;">
      <div style="font-weight:600; margin-bottom:.75rem; text-align:center;">
        Original Implementation
      </div>

      <div class="cta-row" style="justify-content:center;">

        <!-- GitHub Tile -->
        <a class="mini-tile"
          href="https://github.com/fullerj79/fullerj79.github.io/tree/main/original_artifacts"
          target="_blank"
          rel="noopener">

          <div class="mini-play">
            <i class="fa-brands fa-github"></i>
          </div>

          <div>
            <div class="mini-title">View Original Repository</div>
            <div class="mini-sub">Console-based IT-140 artifact</div>
          </div>

        </a>

        <!-- YouTube Tile -->
        <a class="mini-tile"
          href="https://youtube.com/watch?v=p2sD07a2oUg"
          target="_blank"
          rel="noopener">

          <div class="mini-play">
            <i class="fa-brands fa-youtube"></i>
          </div>

          <div>
            <div class="mini-title">Watch the Code Review</div>
            <div class="mini-sub">Walkthrough + plan</div>
          </div>

        </a>

      </div>
    </div>

    <h3>Intentional Enhancement Strategy</h3>

    <p>
      The enhancements were structured deliberately to align directly with the CS 499 outcome categories while minimizing overlap. Software engineering improvements focused on architectural layering, modularity, validation boundaries, and deployment discipline. Algorithmic enhancements introduced graph modeling, breadth-first search validation, and deterministic scoring logic. Database integration introduced persistent identity, saved state management, indexing strategy, and secure configuration controls.
    </p>

    <p>
      Each category builds upon the same artifact, allowing progression to be measured clearly. The result is a transformation from a classroom script into a layered, deployed, persistent application aligned with modern engineering practices.
    </p>

    <p>
      <b>This progression demonstrates not feature expansion, but engineering maturity.</b>
    </p>


    <!-- ENHANCED LABEL -->
    <div style="text-align:center; font-size:.85rem; font-weight:600; letter-spacing:.05em; margin-top:2.5rem; color:var(--muted); text-transform:uppercase;">
      Enhanced Web Application
    </div>

    <!-- ENHANCED IMAGES SIDE BY SIDE -->
    <div style="display:flex; justify-content:center; gap:2rem; flex-wrap:wrap; margin:1.5rem auto 1rem auto; max-width:1100px;">

      <a href="assets/main.jpg" target="_blank" rel="noopener" style="width:48%;">
        <img 
          src="assets/main.jpg"
          alt="Enhanced Application Main Menu"
          style="width:100%; height:auto; border-radius:16px; box-shadow:0 18px 40px rgba(0,0,0,.18);">
      </a>

      <a href="assets/gameplay.jpg" target="_blank" rel="noopener" style="width:48%;">
        <img 
          src="assets/gameplay.jpg"
          alt="Enhanced Application Gameplay"
          style="width:100%; height:auto; border-radius:16px; box-shadow:0 18px 40px rgba(0,0,0,.18);">
      </a>

    </div>

    <div style="text-align:center; font-size:.85rem; color:var(--muted); margin-bottom:1.75rem;">
      Web-based interface with authenticated sessions, persistent state, and deterministic scoring.
    </div>

  <!-- ENHANCED BUTTONS -->
  <div class="callout" style="margin-top:2rem;">
    <div style="font-weight:600; margin-bottom:.75rem; text-align:center;">
      Enhanced Application
    </div>

    <div class="cta-row" style="justify-content:center;">

      <!-- Live Demo Tile -->
      <a class="mini-tile"
        href="https://relicrush.onrender.com"
        target="_blank"
        rel="noopener">

        <div class="mini-play">
          <i class="fa-solid fa-rocket"></i>
        </div>

        <div>
          <div class="mini-title">Launch Live Demo</div>
          <div class="mini-sub">Render.com + MongoDB Atlas</div>
        </div>

      </a>

      <!-- Enhanced GitHub Tile -->
      <a class="mini-tile"
        href="https://github.com/fullerj79/fullerj79.github.io/tree/main/enhanced_artifacts"
        target="_blank"
        rel="noopener">

        <div class="mini-play">
          <i class="fa-brands fa-github"></i>
        </div>

        <div>
          <div class="mini-title">View Enhanced Repository</div>
          <div class="mini-sub">MVC + persistence layer</div>
        </div>

      </a>

    </div>
  </div>


  </div>

  <div class="section" id="enhancements">
    <h2><span class="bar"></span>Capstone Enhancements</h2>

    <p class="muted">
      Each enhancement category below links to a full narrative page that explains what was improved, what skills were demonstrated,
      and how the work aligns with CS 499 course outcomes.
    </p>



    <div class="grid">
      <div class="col-12">
        <div class="section subsection" id="enhancement-1">

          <h2>Software Design & Engineering Enhancement</h2>

          <p class="lead">
            This enhancement transformed RelicRush from a tightly coupled procedural console script into a layered, modular, secure, and deployable web application aligned with modern software engineering practices. The purpose of this enhancement was not to expand gameplay functionality, but to redesign the system using architectural principles that improve maintainability, testability, security, and deployment readiness. This work demonstrates the transition from writing functional academic code to engineering structured software systems designed to evolve safely and operate in real environments.
          </p>


          <h3>Artifact Description</h3>

          <p>
            The original RelicRush artifact was created in December 2023 for IT-140: Introduction to Scripting. It was a console-based adventure game that used procedural logic and dictionary-based state management to track rooms, items, and player progress. The artifact successfully demonstrated foundational programming concepts including loops, conditionals, and state tracking, but it was intentionally limited in architectural sophistication.
          </p>

          <p>
            Gameplay logic, state mutation, input handling, and rendering were tightly coupled inside a single execution flow. Data structures were hard-coded directly into the script, and there was no separation between user interaction, game rules, or system state. This design made the system fragile and difficult to extend safely. Even minor changes required modifying multiple unrelated parts of the program, increasing the risk of unintended side effects.
          </p>

          <p>
            The enhanced version preserves the original gameplay while restructuring the system into a layered architecture aligned with Model View Controller principles. Presentation logic is now isolated in the view layer, controllers coordinate workflows and enforce system rules, domain models encapsulate game state and rule enforcement, and repository classes isolate persistence and infrastructure concerns. This separation enables independent testing, secure configuration, and deployment using modern application workflows.
          </p>

          <p>
            One of the most visible outcomes of this architectural separation is the transition from console interaction to a web-based interface. This change was made possible because presentation logic was isolated from domain logic. The web interface interacts with controllers, which coordinate system behavior without exposing implementation details. This demonstrates that the system is no longer tied to a specific presentation mechanism and can evolve independently of the core gameplay logic.
          </p>


          <h3>Justification for Inclusion</h3>

          <p>
            This artifact was selected because it provides a clear and measurable demonstration of engineering growth. Rather than creating a new project, enhancing an existing artifact required evaluating architectural weaknesses, identifying structural limitations, and deliberately implementing improvements aligned with professional engineering practices.
          </p>

          <p>
            The enhanced artifact demonstrates architectural design capability, modular organization, secure authentication workflows, environment-based configuration management, automated verification through testing, structured logging for operational visibility, and deployment readiness through hosted execution. These improvements reflect engineering practices used in professional environments where systems must be maintainable, secure, and deployable.
          </p>

          <p>
            The enhancement demonstrates not only the ability to write working code, but the ability to design systems that are maintainable and extensible. This distinction reflects the difference between academic programming exercises and professional software engineering.
          </p>


          <h3>Enhancement Impact and Skills Demonstrated</h3>

          <p>
            The most significant improvement was restructuring the system using layered architecture aligned with Model View Controller principles. Responsibilities are now clearly separated across presentation, workflow coordination, domain logic, and persistence boundaries. Controllers coordinate workflows and enforce validation boundaries. Domain models encapsulate state transitions and enforce game rules. Repository classes isolate persistence and infrastructure concerns. Views manage presentation independently of system logic.
          </p>

          <p>
            This separation of concerns improves maintainability and reduces coupling. Changes to presentation do not require modifications to domain logic. Persistence mechanisms can evolve independently of gameplay behavior. Domain logic can be tested independently of infrastructure or presentation layers.
          </p>

          <p>
            The enhancement also introduced authentication workflows backed by MongoDB Atlas. Users can create accounts and authenticate securely. Sensitive configuration values such as database connection strings and credential protection parameters are stored using environment variables rather than embedded in source code. This improves security and aligns with real deployment practices.
          </p>

          <p>
            Automated testing using pytest was implemented across controllers, domain models, repositories, and authentication logic. This provides measurable verification of system correctness and ensures changes can be made safely without introducing regressions.
          </p>

          <p>
            Structured logging replaced print-based debugging, improving traceability and operational visibility. The application was deployed using Render with secure configuration injection and continuous deployment workflows, demonstrating deployment readiness.
          </p>


          <h3>Reflection on the Enhancement Process and Learning</h3>

          <p>
            This enhancement reinforced the importance of architectural design in building maintainable software systems. The original artifact was functional but fragile. Its tightly coupled structure made changes difficult and risky. Refactoring the system required identifying responsibility boundaries and deliberately separating concerns into independent layers.
          </p>

          <p>
            One of the most valuable lessons learned was how architectural separation improves testability. By isolating domain logic from presentation and infrastructure, core system behavior could be validated independently using automated tests. This made it possible to achieve high test coverage while maintaining flexibility in the presentation layer.
          </p>

          <p>
            Implementing authentication and secure configuration management reinforced the importance of security-aware design. Treating configuration values and credentials as environment-provided secrets rather than hard-coded constants reflects secure engineering practices used in professional environments.
          </p>

          <p>
            Deploying the application also provided valuable experience in operational readiness. Structuring the system to run in a hosted environment required careful separation of configuration, application logic, and infrastructure concerns. This demonstrated how architectural design directly affects deployment feasibility.
          </p>

          <p>
            Overall, this enhancement demonstrated the transition from writing procedural scripts to engineering structured software systems designed for maintainability, security, and deployment.
          </p>


          <h3>Alignment with CS 499 Course Outcomes</h3>

          <h4>Outcome 1: Collaborative System Design</h4>

          <p>
            The layered architecture improves maintainability and supports collaborative development by clearly separating responsibilities. Developers can work within specific layers without needing to understand the entire system, reducing cognitive load and improving team productivity.
          </p>

          <h4>Outcome 2: Professional Technical Communication</h4>

          <p>
            The structured architecture, project organization, and technical documentation presented in this portfolio demonstrate professional communication of system design and implementation.
          </p>

          <h4>Outcome 3: Algorithmic Principles and Tradeoffs</h4>

          <p>
            Architectural separation demonstrates understanding of engineering tradeoffs between simplicity and maintainability. Introducing layered architecture increases structural complexity but improves long-term maintainability and testability.
          </p>

          <h4>Outcome 4: Modern Engineering Tools and Practices</h4>

          <p>
            This enhancement demonstrates use of modern engineering practices including layered architecture, automated testing, secure configuration management, structured logging, and cloud deployment workflows.
          </p>

          <h4>Outcome 5: Security Mindset</h4>

          <p>
            Secure authentication workflows, environment-based secret management, and deployment-ready configuration demonstrate a security-focused engineering approach.
          </p>


          <button class="toggle-btn"
            onclick="toggleContent('enhancement1-content', this, 'Show Technical Implementation Details', 'Hide Technical Implementation Details')"
            aria-expanded="false"
            aria-controls="enhancement1-content">
            Show Technical Implementation Details
          </button>


        <div id="enhancement1-content" class="collapsible">

          <h3>Architectural Refactor and Layered Design</h3>

          <p>
            The original artifact centralized all responsibilities inside a procedural execution loop. Gameplay rules, state mutation, user input handling, and rendering were tightly coupled. This structure made the system fragile, difficult to test independently, and unsafe to modify without unintended side effects.
          </p>

          <p>
            The enhanced version restructures the system into a layered architecture aligned with Model View Controller principles. Each layer has a clearly defined responsibility boundary. Controllers coordinate workflows and enforce input validation. Domain models encapsulate authoritative state and rule enforcement. Repository classes isolate persistence logic and database interaction. Views handle presentation independently of system logic. Utility modules provide cross-cutting services such as logging and configuration management.
          </p>

          <p>
            This separation of concerns improves maintainability, enables isolated testing of core logic, and allows the system to evolve safely over time.
          </p>


        <pre>
        project/
        │
        ├── app.py
        │   → Application entry point responsible for initializing the Flask server,
        │     configuring routes, loading environment configuration, and wiring together
        │     controllers, repositories, and domain services. This file establishes the
        │     runtime environment and serves as the integration boundary between layers.
        │
        ├── controllers/
        │   → Workflow coordination layer responsible for handling incoming user requests,
        │     validating input boundaries, managing session context, and invoking domain
        │     logic and repository operations. Controllers act as the bridge between the
        │     presentation layer and the domain layer while enforcing system rules and
        │     protecting internal state from direct manipulation.
        │
        ├── models/
        │   ├── domain/
        │   │   → Defines authoritative system state and rule enforcement. Domain models
        │   │     encapsulate game state, lifecycle transitions, win/loss evaluation, and
        │   │     rule validation. This ensures gameplay behavior remains deterministic,
        │   │     testable, and independent of infrastructure or presentation concerns.
        │   │
        │   ├── behavior/
        │   │   → Encapsulates behavioral policies such as difficulty settings, scoring
        │   │     strategies, and rule variations. This isolates policy logic from domain
        │   │     state, allowing behavior to evolve independently and preventing controller
        │   │     logic from becoming overloaded with conditional branching.
        │   │
        │   └── repositories/
        │       → Persistence abstraction layer responsible for all database interaction.
        │         Repository classes isolate MongoDB queries and storage operations from
        │         domain logic. This separation allows domain models to remain storage-
        │         agnostic and enables substitution of alternate persistence strategies
        │         without modifying core logic.
        │
        ├── db/
        │   → Database initialization and configuration layer. This module establishes
        │     MongoDB connections using environment-provided credentials, configures
        │     collections, and ensures secure runtime access without exposing sensitive
        │     information in source code.
        │
        ├── views/
        │   → Presentation layer responsible for rendering user interface templates and
        │     displaying system state. Views operate independently of domain logic and
        │     communicate with controllers to execute workflows. This separation enables
        │     changes to the user interface without affecting core gameplay behavior.
        │
        ├── tests/
        │   → Automated pytest test suite validating system correctness. Tests cover domain
        │     logic, controller workflows, authentication behavior, and persistence
        │     operations. This ensures correctness and protects against regression during
        │     refactoring and enhancement.
        │
        └── utils/
            → Cross-cutting infrastructure utilities including structured logging,
              environment configuration helpers, and shared services used across layers.
              This prevents duplication and centralizes infrastructure concerns.
        </pre>


          <h3>Presentation Layer Separation</h3>

          <p>
            The original artifact handled presentation directly within the gameplay loop using console input and output. This tightly coupled presentation with system logic, making it difficult to test core functionality independently or introduce alternate interfaces.
          </p>

          <p>
            In the enhanced system, presentation responsibilities are isolated within the views layer. User interaction is rendered using HTML templates, while controllers process input and invoke domain logic. This separation ensures that presentation changes do not impact business rules or state management.
          </p>

          <div class="img-row">

            <div class="figure">
              <img src="assets/main.jpg"
                  style="height:180px; width:auto;"
                  alt="Gameplay interface">
              <div class="small-cap">
                Gameplay interface operating independently of domain logic through controller coordination.
              </div>
            </div>

            <div class="figure">
              <img src="assets/login.jpg"
                  style="height:180px; width:auto;"
                  alt="Login interface">
              <div class="small-cap">
                Authentication interface isolated from credential storage and validation logic.
              </div>
            </div>

          </div>


          <h3>Authentication and Secure Credential Management</h3>

          <p>
            Authentication workflows were introduced to support secure user identity management. Signup and login workflows validate credentials against MongoDB Atlas using salted and hashed password storage. Sensitive credential protection parameters such as the hashing pepper and database connection URI are stored securely as environment variables.
          </p>

          <p>
            This approach prevents credential exposure in source code and ensures secure authentication workflows consistent with modern security practices.
          </p>

          <div class="img-row">

            <div class="figure">
              <img src="assets/signup.jpg"
                  style="height:180px; width:auto;"
                  alt="Signup interface">
              <div class="small-cap">
                Secure credential creation workflow validating inputs before persistence.
              </div>
            </div>

          </div>


          <h3>Automated Testing and Verification</h3>

          <p>
            Automated testing was implemented using pytest to validate correctness across controllers, domain models, repository logic, and authentication workflows. Tests verify rule enforcement, state transitions, persistence correctness, and authentication behavior.
          </p>

          <p>
            The presentation layer was intentionally excluded from automated unit coverage because architectural separation allows domain behavior to be tested independently of UI rendering. This approach improves test reliability and ensures core system correctness regardless of presentation implementation.
          </p>

          <p>
            This testing strategy provides measurable verification of correctness and protects against regression during ongoing enhancement.
          </p>

          <div class="img-row">

            <div class="figure">
              <img src="assets/pytestresults.jpg"
                  style="width:520px; max-width:100%;"
                  alt="Pytest coverage results">
              <div class="small-cap">
                Pytest results demonstrating high coverage across core architectural layers.
              </div>
            </div>

          </div>


          <h3>Structured Logging and Operational Observability</h3>

          <p>
            Structured logging replaced print-based debugging to improve traceability and operational visibility. Logging captures authentication events, controller workflows, state transitions, and error conditions. This provides diagnostic insight necessary for debugging deployed systems.
          </p>

          <div class="img-row">

            <div class="figure">
              <img src="assets/logger.jpg"
                  style="width:520px; max-width:100%;"
                  alt="Structured logging output">
              <div class="small-cap">
                Structured logging providing traceability of system behavior.
              </div>
            </div>

          </div>


          <h3>Deployment Architecture and Continuous Deployment Workflow</h3>

          <p>
            The enhanced application is deployed using Render as a hosted web service. Deployment configuration uses environment variables to securely inject database credentials and authentication secrets at runtime. Continuous deployment workflows rebuild and redeploy the application automatically when repository changes are detected.
          </p>

          <p>
            This deployment demonstrates operational readiness and validates that the application architecture supports secure execution in a hosted environment.
          </p>

          <div class="img-row">

            <div class="figure">
              <img src="assets/renderdeploy.jpg"
                  style="width:520px; max-width:100%;"
                  alt="Render deployment configuration">
              <div class="small-cap">
                Render deployment pipeline demonstrating hosted application execution.
              </div>
            </div>

          </div>


          <h3>Engineering Impact of Refactor</h3>

          <p>
            This refactor transformed the artifact from a tightly coupled academic script into a modular, secure, and deployable software system aligned with modern engineering practices. The system now demonstrates layered architecture, secure authentication, automated testing, structured logging, and production-ready deployment workflows.
          </p>

          <p>
            These improvements reflect engineering maturity and demonstrate the ability to design software systems that are maintainable, testable, secure, and deployable.
          </p>

        </div>

        </div>
      </div>
      <div class="col-12">
        <div class="section subsection" id="enhancement-2">

          <h2>Algorithms & Data Structures Enhancement</h2>

          <p class="lead">
            This enhancement transformed RelicRush from a procedural game driven by implicit control flow into a system built on explicit state modeling, graph-based reasoning, and deterministic algorithmic evaluation. The purpose of this enhancement was to redesign the system so that correctness, solvability, and performance could be evaluated using formal computer science principles. This work demonstrates the transition from procedural scripting to deliberate algorithmic engineering grounded in data structures, graph theory, and deterministic computation.
          </p>


          <h3>Artifact Description</h3>

          <p>
            The original RelicRush artifact used dictionaries and conditional branching to control gameplay flow. While this implementation functioned correctly, it did not formally model game state, and traversal logic was embedded directly in procedural execution. Room relationships were implicit, and there was no algorithmic validation to guarantee solvability or correctness of traversal logic.
          </p>

          <p>
            State was managed using loosely structured variables, which made it difficult to reason about correctness or validate gameplay behavior independently. There was no formal mechanism to measure traversal efficiency or evaluate performance against optimal solutions.
          </p>

          <p>
            The enhanced version introduces explicit state modeling through domain objects and formal graph representation of the game map. Rooms are modeled as graph nodes and exits as graph edges. Breadth First Search traversal is used to compute optimal paths, enabling deterministic performance evaluation and correctness guarantees.
          </p>


          <h3>Justification for Inclusion</h3>

          <p>
            This artifact was selected because it demonstrates the application of core computer science concepts including graph modeling, algorithmic traversal, deterministic state management, and performance evaluation. Rather than relying on implicit procedural execution, the enhanced system uses explicit data structures and algorithms to enforce correctness and improve system reliability.
          </p>

          <p>
            The enhancement demonstrates skills in algorithm selection, state modeling, graph traversal, deterministic scoring, and performance evaluation. These improvements reflect foundational computer science competencies and demonstrate the ability to redesign systems using formal computational reasoning.
          </p>


          <h3>Enhancement Impact and Skills Demonstrated</h3>

          <p>
            The most significant improvement was introducing explicit state modeling using structured domain objects. GameState now serves as the authoritative source of truth for gameplay state. This ensures state consistency and improves reliability.
          </p>

          <p>
            The map is represented as a graph, enabling traversal analysis using Breadth First Search. BFS guarantees shortest path computation in unweighted graphs, ensuring solvability and enabling objective performance measurement.
          </p>

          <p>
            Deterministic scoring was introduced using algorithmic evaluation. Player performance is evaluated relative to optimal traversal paths computed using BFS, ensuring objective and reproducible scoring.
          </p>


          <h3>Reflection on the Enhancement Process and Learning</h3>

          <p>
            This enhancement reinforced the importance of formal state modeling and algorithmic correctness. Procedural implementations may function correctly but lack guarantees about correctness and performance. Explicit data structures and algorithms provide measurable correctness guarantees and improve reliability.
          </p>

          <p>
            Implementing Breadth First Search reinforced understanding of graph traversal algorithms and their practical applications. Modeling traversal as graph computation enables objective reasoning about system behavior.
          </p>

          <p>
            This work demonstrated how algorithmic engineering improves correctness, predictability, and system reliability.
          </p>


        <h3>Alignment with CS 499 Course Outcomes</h3>

        <p>
        This enhancement demonstrates the deliberate application of computer science principles to redesign system behavior using formal state modeling, graph traversal algorithms, and deterministic performance evaluation. By replacing implicit procedural execution with explicit data structures and algorithmic reasoning, the system now provides measurable correctness guarantees and predictable behavior aligned with professional software engineering practices.
        </p>


        <h4>Outcome 1: Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making</h4>

        <p>
        This enhancement improves system clarity and maintainability by introducing structured domain models and explicit graph representation. Encapsulating gameplay state inside a dedicated GameState model creates clear responsibility boundaries and makes system behavior easier to understand. Modeling traversal using graph structures ensures that relationships between components are explicit rather than embedded in procedural logic. This clarity allows developers to reason about system behavior independently, supporting collaborative development and safe extension of functionality.
        </p>


        <h4>Outcome 2: Design, develop, and deliver professional-quality technical communication</h4>

        <p>
        The enhanced system improves communication of technical intent by structuring traversal, state management, and scoring around explicit domain models and formal algorithms. Graph modeling and deterministic scoring clearly communicate how traversal efficiency is evaluated. The organization of domain models, algorithm implementation, and supporting documentation provides a clear representation of system behavior. This reflects the ability to communicate technical design decisions in a structured and professional manner.
        </p>


        <h4>Outcome 3: Design and evaluate computing solutions using algorithmic principles and computer science practices</h4>

        <p>
        This enhancement directly demonstrates the application of algorithmic principles through graph modeling and Breadth First Search traversal. BFS guarantees shortest path discovery in unweighted graphs, allowing optimal traversal distances to be computed reliably. This enables objective performance evaluation and ensures gameplay solvability. Explicit state modeling using appropriate data structures ensures deterministic state transitions and reliable behavior. These improvements reflect deliberate application of algorithmic reasoning to improve correctness and system reliability.
        </p>


        <h4>Outcome 4: Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices</h4>

        <p>
        This enhancement demonstrates the use of appropriate data structures and structured algorithm implementation to improve system performance and maintainability. Sets are used to efficiently track visited rooms and collected items, ensuring efficient lookup and preventing state inconsistency. Graph structures enable traversal analysis, and domain models encapsulate system behavior. These design decisions reflect deliberate use of established computing practices to improve correctness and maintainability.
        </p>


        <h4>Outcome 5: Develop a security mindset that anticipates vulnerabilities and protects system resources</h4>

        <p>
        Structured state modeling improves system reliability by preventing invalid state transitions and ensuring consistent lifecycle management. Encapsulating state transitions inside controlled domain models prevents unintended modification of critical system state. This reduces the risk of invalid system behavior and ensures predictable execution. These practices reflect a disciplined engineering approach focused on protecting system integrity and reliability.
        </p>


          <button class="toggle-btn"
            onclick="toggleContent('enhancement2-content', this, 'Show Technical Implementation Details', 'Hide Technical Implementation Details')"
            aria-expanded="false"
            aria-controls="enhancement2-content">
            Show Technical Implementation Details
          </button>

        <div id="enhancement2-content" class="collapsible">

        <h3>Authoritative GameState Model and Deterministic State Management</h3>

        <p>
        The original artifact managed state using loosely scoped procedural variables. This made correctness difficult to verify and introduced risk of inconsistent state transitions. The enhanced version introduces a structured GameState domain model that serves as the single authoritative source of truth. All state transitions occur through controlled methods rather than implicit procedural mutation.
        </p>

        <p>
        Encapsulating state inside a domain model improves correctness, enforces invariant conditions, and enables deterministic testing of state transitions independent of presentation or controller workflows.
        </p>

        <pre>
        GameState Domain Model
        │
        ├── player : Player
        │   → Tracks current room identifier using Player.location.
        │   → Ensures location transitions occur only through validated movement logic.
        │
        ├── visited_rooms : set[str]
        │   → Records traversal history.
        │   → Provides efficient O(1) lookup to prevent redundant state transitions.
        │
        ├── collected_items : set[str]
        │   → Tracks inventory using set semantics to prevent duplicate entries.
        │   → Improves correctness and lookup performance.
        │
        ├── move_count : int
        │   → Tracks traversal steps for deterministic scoring evaluation.
        │
        ├── status : GameStatus
        │   → Represents lifecycle state (active, win, lose).
        │   → Ensures system correctness through explicit lifecycle transitions.
        │
        └── event_log : list
            → Records state transitions for debugging and traceability.
        </pre>


        <h3>Graph-Based Map Representation and Traversal Model</h3>

        <p>
        The original artifact stored room relationships using dictionary lookups embedded directly in gameplay logic. This made traversal behavior implicit and difficult to analyze formally. The enhanced version models the game world as a graph structure, where rooms represent nodes and connections represent edges.
        </p>

        <p>
        This explicit graph representation enables traversal analysis using formal algorithms and guarantees consistency of navigation logic.
        </p>

        <pre>
        Graph Model
        │
        ├── Nodes
        │   → Each room is represented as a graph node.
        │   → Node identity ensures deterministic traversal tracking.
        │
        └── Edges
            → Connections between rooms represented as graph edges.
            → Enforces valid traversal paths and prevents invalid transitions.
        </pre>


        <h3>Breadth First Search Traversal Algorithm</h3>

        <p>
        Breadth First Search was implemented to compute optimal traversal paths between rooms. BFS guarantees shortest path discovery in unweighted graphs. This ensures that optimal traversal distances can be computed reliably and used for performance evaluation.
        </p>

        <p>
        BFS traversal establishes formal guarantees about game solvability and optimal path computation, eliminating reliance on implicit procedural traversal behavior.
        </p>

        <pre>
        Breadth First Search Traversal Flow
        │
        ├── Initialize traversal queue
        │   → Begin with starting node.
        │
        ├── Track visited nodes using set structure
        │   → Prevent infinite traversal loops.
        │
        ├── Visit neighbor nodes iteratively
        │   → Explore graph level by level.
        │
        ├── Record traversal distance for each node
        │   → Enables optimal move computation.
        │
        └── Terminate traversal upon reaching target node
            → Guarantees shortest path discovery.
        </pre>


        <h3>Deterministic Scoring Algorithm and Performance Evaluation</h3>

        <p>
        The original artifact used arbitrary scoring logic without measurable correctness guarantees. The enhanced version computes score deterministically using optimal traversal paths computed via BFS.
        </p>

        <p>
        This establishes objective performance evaluation based on algorithmic computation rather than procedural execution order.
        </p>

        <pre>
        Deterministic Score Evaluation
        │
        ├── Compute optimal traversal path using BFS
        │
        ├── Track actual traversal moves from GameState
        │
        ├── Compute efficiency ratio
        │   → efficiency = optimal_moves / actual_moves
        │
        └── Generate deterministic score based on efficiency and completion state
        </pre>


        <h3>Difficulty Strategy Abstraction and Behavioral Modeling</h3>

        <p>
        Difficulty settings are implemented using structured behavioral models rather than procedural branching. Difficulty policies influence scoring, visibility, and traversal constraints through structured behavioral modules.
        </p>

        <p>
        This isolates policy logic from core state management and improves maintainability.
        </p>

        <pre>
        Difficulty Behavior Model
        │
        ├── Difficulty Enum
        │   → Defines available difficulty levels.
        │
        ├── Behavior Policy Modules
        │   → Encapsulate scoring multipliers and traversal visibility rules.
        │
        └── Strategy Selection Logic
            → Applies appropriate behavioral policy during execution.
        </pre>


        <h3>Algorithmic Testability and Verification Improvements</h3>

        <p>
        Explicit state models and algorithm isolation allow independent validation of traversal correctness and scoring logic. BFS computation, state transitions, and scoring evaluation can be verified using automated tests without relying on presentation or user interaction.
        </p>

        <p>
        This dramatically improves system reliability and enables deterministic verification of algorithm correctness.
        </p>


        <h3>Engineering Impact of Algorithmic Refactor</h3>

        <p>
        This enhancement transformed traversal and scoring from implicit procedural behavior into formally defined algorithmic computation. Graph modeling, structured state management, and deterministic scoring ensure correctness, improve testability, and enable objective performance evaluation. These improvements reflect core computer science principles and demonstrate algorithmic engineering maturity.
        </p>

        </div>



        </div>
      </div>
      <div class="col-12">
        <div class="section subsection" id="enhancement-3">

        <h2>Database Enhancement</h2>

        <p class="lead">
        This enhancement transformed RelicRush from an in-memory, single-session script into a persistent, secure, and deployable application backed by MongoDB Atlas. The purpose of this enhancement was to introduce structured persistence, user identity management, and secure data storage aligned with professional database engineering practices.
        </p>


        <h3>Artifact Description</h3>

        <p>
        The original artifact stored all gameplay state in memory. State was lost when execution ended. There was no persistence, identity management, or ability to resume sessions.
        </p>

        <p>
        The enhanced version introduces MongoDB Atlas as a persistent storage system. Users can create accounts, authenticate securely, save game progress, and resume sessions.
        </p>


        <h3>Justification for Inclusion</h3>

        <p>
        This enhancement demonstrates database engineering skills including schema design, repository abstraction, persistence modeling, and secure configuration management.
        </p>

        <p>
        The system now reflects real-world application persistence patterns and secure credential handling.
        </p>


        <h3>Enhancement Impact and Skills Demonstrated</h3>

        <p>
        Persistence was implemented using MongoDB Atlas with repository abstraction separating persistence logic from domain logic.
        </p>

        <p>
        Environment variables secure database credentials and configuration.
        </p>


        <h3>Reflection on Learning</h3>

        <p>
        This enhancement demonstrated the importance of persistence architecture and secure credential handling in real-world systems.
        </p>


        <h3>Alignment with CS 499 Course Outcomes</h3>

        <p>
        This enhancement demonstrates the ability to design secure, persistent data storage systems aligned with professional software engineering practices. Introducing MongoDB Atlas persistence, repository abstraction, bootstrap initialization, and index enforcement transformed the artifact from a temporary script into a durable application capable of secure identity management and persistent state tracking. These improvements reflect deliberate architectural design aligned with industry standards.
        </p>


        <h4>Outcome 1: Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making</h4>

        <p>
        Repository abstraction improves system maintainability and clarity by isolating persistence logic from application logic. Developers can work within the domain layer, controller layer, or repository layer independently without needing to understand the entire system. This separation of concerns supports collaborative development and allows persistence implementation to evolve independently of domain behavior.
        </p>


        <h4>Outcome 2: Design, develop, and deliver professional-quality technical communication</h4>

        <p>
        The enhanced persistence architecture clearly communicates how data is stored, retrieved, and managed. Repository abstraction, bootstrap initialization, and environment-based configuration provide structured and understandable persistence workflows. The organization of persistence components and documentation clearly communicates system design and implementation decisions in a professional and structured manner.
        </p>


        <h4>Outcome 3: Design and evaluate computing solutions using algorithmic principles and computer science practices</h4>

        <p>
        Bootstrap initialization ensures that collections and indexes are created consistently across environments, guaranteeing predictable database structure and query performance. Index enforcement improves lookup efficiency and ensures reliable identity management. These improvements demonstrate deliberate application of computer science principles to improve performance, reliability, and correctness.
        </p>


        <h4>Outcome 4: Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices</h4>

        <p>
        The use of MongoDB Atlas introduces modern document-oriented persistence aligned with industry practices. Atlas provides managed infrastructure, secure connections, and durable storage. Repository abstraction improves maintainability and enables independent testing. Environment-based configuration ensures secure deployment. These practices reflect professional software engineering standards.
        </p>


        <h4>Outcome 5: Develop a security mindset that anticipates vulnerabilities and protects system resources</h4>

        <p>
        Secure database integration is implemented using environment variables to protect sensitive configuration values such as database connection strings and authentication secrets. MongoDB Atlas provides encrypted connections and network access controls to prevent unauthorized access. These security measures protect user identity data and ensure safe system operation in deployed environments.
        </p>


        <button class="toggle-btn"
        onclick="toggleContent('enhancement3-content', this, 'Show Technical Implementation Details', 'Hide Technical Implementation Details')">
        Show Technical Implementation Details
        </button>

        <div id="enhancement3-content" class="collapsible">

        <h3>Persistence Architecture and Repository Boundaries</h3>

        <p>
        The enhanced system introduces persistent storage using MongoDB Atlas, replacing the original artifact’s in-memory state model. Persistence responsibilities are isolated behind repository classes, ensuring domain logic remains independent of storage implementation. Controllers coordinate workflows and invoke repository operations, while domain models remain storage-agnostic.
        </p>

        <p>
        This architectural separation improves maintainability, enables testability without requiring live database connections, and ensures persistence logic can evolve independently of application behavior.
        </p>

        <pre>
        Persistence Architecture
        │
        ├── Controllers
        │   → Coordinate persistence operations and enforce workflow boundaries.
        │
        ├── Repository Layer
        │   → Encapsulates MongoDB access logic.
        │   → Prevents direct database interaction from domain models.
        │
        └── MongoDB Atlas
            → Provides managed, durable document storage.
        </pre>


        <h3>MongoDB Atlas Integration and Managed Database Infrastructure</h3>

        <p>
        MongoDB Atlas provides fully managed document storage, removing the need to manage database infrastructure manually. Atlas handles replication, durability, connection security, and availability. The application connects to Atlas using secure connection strings injected through environment variables.
        </p>

        <p>
        Atlas also enforces network access controls and encrypted connections, ensuring secure communication between the application and database.
        </p>

        <pre>
        Atlas Integration Components
        │
        ├── Managed Database Cluster
        │   → Provides persistent document storage.
        │
        ├── Secure Connection URI
        │   → Injected through environment configuration.
        │
        └── Network Access Controls
            → Restricts database access to authorized environments.
        </pre>


        <h3>Bootstrap Initialization and Index Enforcement</h3>

        <p>
        A bootstrap initialization process ensures database collections exist and required indexes are applied automatically. This guarantees consistent database structure and predictable query performance across environments.
        </p>

        <p>
        Indexes improve lookup performance, enforce identity uniqueness, and ensure efficient query execution.
        </p>

        <pre>
        Bootstrap Responsibilities
        │
        ├── Initialize required collections
        │   → users
        │   → saves
        │   → history
        │
        ├── Apply collection indexes
        │   → users: unique index on username
        │   → saves: index on user_id
        │   → history: index on score and timestamp
        │
        └── Ensure consistent schema structure
        </pre>


        <h3>Repository Layer and Storage Isolation</h3>

        <p>
        Repository classes isolate database interaction from application logic. This prevents controllers and domain models from interacting directly with MongoDB, improving separation of concerns and enabling independent testing.
        </p>

        <pre>
        Repository Layer Structure
        │
        ├── UserRepository
        │   → Creates and retrieves user identity records.
        │
        ├── SaveRepository
        │   → Persists and restores game state.
        │
        └── HistoryRepository
            → Stores completed gameplay results and leaderboard data.
        </pre>


        <h3>Secure Configuration Using Environment Variables</h3>

        <p>
        Sensitive configuration values such as database connection URI, database name, and authentication secrets are injected through environment variables rather than hard-coded in source files. This prevents credential exposure and supports secure deployment practices.
        </p>

        <pre>
        Environment Configuration
        │
        ├── MONGO_URI
        │   → Atlas connection string
        │
        ├── DATABASE_NAME
        │   → Target database
        │
        └── AUTH_PEPPER
            → Credential protection secret
        </pre>


        <h3>Testability Through Repository Abstraction</h3>

        <p>
        Repository abstraction allows persistence logic to be replaced with in-memory implementations during testing. This enables deterministic testing of persistence workflows without requiring live database connections.
        </p>

        <p>
        This improves test speed, reliability, and system maintainability.
        </p>


        <h3>Engineering Impact of Persistence Enhancement</h3>

        <p>
        This enhancement transformed RelicRush from a temporary script into a persistent, secure application aligned with modern database engineering practices. Bootstrap initialization ensures consistent schema and index enforcement. MongoDB Atlas provides durable storage and managed infrastructure. Repository abstraction ensures clean architectural boundaries and improves maintainability.
        </p>

        <p>
        These improvements demonstrate the ability to design persistence systems that are secure, testable, and aligned with professional deployment standards.
        </p>

        </div>

        </div>
      </div>
    </div>
  </div>

  <div class="section" id="contact">
    <h2><span class="bar"></span>Contact</h2>

    <div class="contact-card">
      <p class="muted" style="margin:0;">
        The fastest way to reach me is by email or LinkedIn.
      </p>

      <div class="contact-actions">
        <a class="contact-link" href="mailto:jasonfuller1979@gmail.com" aria-label="Email Jason">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M4 6h16v12H4z" fill="none" stroke="currentColor" stroke-width="2"/>
            <path d="M4 7l8 6 8-6" fill="none" stroke="currentColor" stroke-width="2"/>
          </svg>
          jasonfuller1979@gmail.com
        </a>

        <a class="contact-link" href="tel:860-309-6068" aria-label="Call Jason">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M6.5 3.5l3 2-1 2c1.2 2.2 3 4 5.2 5.2l2-1 2 3c.4.6.2 1.4-.3 1.8-1 .8-2.4 1.3-3.8 1.2-6.5-.4-11.7-5.6-12.1-12.1-.1-1.4.4-2.8 1.2-3.8.4-.5 1.2-.7 1.8-.3z"
                  fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
          </svg>
          860-309-6068
        </a>

        <a class="contact-link" href="https://www.linkedin.com/in/jason-fuller-2569347" target="_blank" rel="noopener" aria-label="Jason on LinkedIn">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M4 4h4v16H4zM6 3.5a2 2 0 110 4 2 2 0 010-4zM10 9h4v2c.6-1.2 2.2-2.2 4.2-2.2C21 8.8 22 10.6 22 13v7h-4v-6.2c0-1.5-.5-2.5-1.8-2.5-1 0-1.6.7-1.9 1.3-.1.2-.1.6-.1.9V20h-4z"
                  fill="currentColor"/>
          </svg>
          LinkedIn
        </a>

        <a class="contact-link" href="https://github.com/fullerj79" target="_blank" rel="noopener" aria-label="Jason on GitHub">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M12 2a10 10 0 00-3.2 19.5c.5.1.7-.2.7-.5v-1.8c-2.9.6-3.5-1.4-3.5-1.4-.5-1.2-1.1-1.5-1.1-1.5-.9-.6.1-.6.1-.6 1 .1 1.6 1 1.6 1 .9 1.6 2.4 1.1 3 .9.1-.7.4-1.1.7-1.4-2.3-.3-4.7-1.1-4.7-5a3.9 3.9 0 011-2.7 3.6 3.6 0 01.1-2.7s.9-.3 2.8 1a9.7 9.7 0 015.2 0c1.9-1.3 2.8-1 2.8-1a3.6 3.6 0 01.1 2.7 3.9 3.9 0 011 2.7c0 3.9-2.4 4.7-4.7 5 .4.3.8 1 .8 2.1v3.1c0 .3.2.6.7.5A10 10 0 0012 2z"/>
          </svg>
          GitHub
        </a>
      </div>
    </div>
  </div>

  <div class="footer">
    © 2026 Jason Fuller · Built with GitHub Pages
  </div>

  <script>
  /* =====================================================================
    GENERIC COLLAPSIBLE CONTROLLER
    Used by all enhancement sections
    ===================================================================== */

  function toggleContent(contentId, button, collapsedText, expandedText) {
    const content = document.getElementById(contentId);
    const isOpen  = content.style.display === "block";

    if (!isOpen) {
      content.style.display = "block";
      button.textContent = expandedText;
      button.setAttribute("aria-expanded", "true");

    } else {
      content.style.display = "none";
      button.textContent = collapsedText;
      button.setAttribute("aria-expanded", "false");
    }
  }

  </script>

</div>
